# 集合的使用
## 集合和运算

+ 集合的本质是许多唯一对象的聚集，因此，集合可以用来去重。

```python
l = ['ABC', 'abc', 'ABC', 'def']
print(set(l))
```
+ 集合中的元素必须是散列的
+ 集合实现了很多中缀运算符，比如`a | b`代表求a和b的合集，`a & b`代表求a和b的交集，`a - b`代表a和b的差集（属于a但是不属于b的元素组成的集合叫做a和b的差集）。

```python
l1 = {'ABC', 'AYU'}
l2 = {'ABC', 'DEF', 'abc', 'XYZ'}
print(l1 & l2)
# l1 和 l2的差集
print(l1 - l2)
# l2 和 l1 的差集
print(l2 - l1)
```

## 集合字面量
集合的空集表示成：`set()`
集合其他形式的字面量展现为： `{1}, {1, 2}`
## 集合推导
和列表推导、字典推导一样，集合也可以通过集合推导的方式构建一个新的集合
每一个字符都有自己的名字，下面的示例就是将名字中含有”SIGN“的字符构建一个集合，然后将这些字符的名字构成一个集合。

```python
from unicodedata import name
l3 = {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
l4 = {name(chr(i)) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
print(l3)
print(l4)
```

## 集合的操作
### 集合的数学运算

数学符号 | Python运算符 | 方法 | 描述
----| ---- | ---- | ----
S ∩ Z | s & z | `s.__and__(z)` | s 和 z 的交集
S ∩ Z | z & s | `s.__rand__(z)` | 反向 & 操作
S ∩ Z | | `s.intersection(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的交集
S ∩ Z | s &= z | `s.__iand__(z)` | 把s更新为s和z的交集
S ∩ Z |  | `s.intersection_update(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的交集，然后把s更新为这个交集
S ∪ Z | s `|` z | `s.__or__(z)` | s和z的并集
S ∪ Z | z `|` s | `s.__ror__(z)` | 并集的反向操作
S ∪ Z |  | `s.union(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的并集
S ∪ Z | s `|=` z | `s.__ior__(z)` | 把s更新为s和z的并集
S ∪ Z |  | `s.update(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的并集，并把s更新为这个并集
S \ Z | s - z | `s.__sub__(z)` | s 和 z的差集，或者叫做相对补集
S \ Z | z - s | `s.__rsub__(z)` | 差集的反向操作
S \ Z |  | `s.difference(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的差集
S \ Z | s -= z | `s.__isub__(z)` | 把s更新为它与z的差集
S \ Z |  | `s.difference_update(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的差集，并把s更新成这个差集
S △ Z |  | `s.symmetric_difference(it)` | 求s和set（it）的对称差集
S △ Z | s ^ z | `s.__xor__(z)` | 求s和z的对称差集
S △ Z | z ^ s | `s.__rxor__(z)` | 对称差集的反向操作
S △ Z |  | `s.symmetric_difference_update(it, ...)` | 把可迭代的it和其他所有参数转化为集合，然后求他们与s的对称差集，然后把s更新成这个对称差集
S △ Z | s ^= z | `s.__ixor__(z)` | 把s更新成它与z的对称差集

### 集合的比较运算符，返回值是布尔类型

数学符号 | Python运算符 | 方法 | 描述
---- | ---- | ---- | ----
| | | `s.isdisjoint(z)` | 查看s和z是否不相交（没有共同元素）
e ∈ s | e in s | `s.__contains__(e)` | 元素e是否属于s
S ⊆ Z | s <= z | `s.__le__(z)` | s 是否为 z 的子集
| | | `s.issubset(it)` | 把可迭代的it转换为集合，然后查看s是否是它的子集
S ⊂ Z | s < z | `s.__lt__(z)` | s 是否为 z 的真子集
S ⊇ Z | s >= z | `s.__ge__(z)` | s 是否为 z 的父集
| | | `s.issuperset(it)` | 把可迭代的it转换为集合，然后查看s是否是它的父集
S ⊃ Z | s > z | `s.__gt__(z)` | s 是否为 z 的真父集

### 集合类型的其他方法

 方法 | set | frozenset | 描述
 ---- | ---- | ---- | ----
 `s.add(e)` | ✅ | | 把元素e添加到集合s中
 `s.clear()` | ✅ | | 清空s集合
 `s.copy()` | ✅ | ✅ | 对s进行浅复制
 `s.discard(e)` | ✅ | | 如果s中有e这个元素，则将其移除
 `s.__iter__()` | ✅ | ✅ | 返回s的迭代器
 `s.__len__()` | ✅ | ✅ | `len(s)`
 `s.pop()` | ✅ | | 从s中移除一个元素，并返回它的值，若s为空，则抛出KeyError异常
 `s.remove(e)` | ✅ | | 从s中移除e元素，若e元素不存在，则抛出KeyError异常

## 字典中的散列表
散列表其实是一个稀疏数组，散列表的单元通常叫做表元。Python会设法保证大概有三分之一的表元是空的，所以在快要达到这个阙值的时候，会将所有的散列表复制到一个更大的空间。
在dict的散列表中，一个表元包含两部分，一个是键的引用，一个是值的引用，因为都是引用，所以表元的大小都是一致的，从而实现了通过偏移量读取表元。

### 散列值和相等性
如果要将一个元素放进散列表中，则必须计算这个元素的散列值，内置的`hash()`可以用于所有的内置类型对象，也可以自己实现`__hash__()`方法，要保证的是如果两个对象在比较的时候是相等的，则其散列值必须相同。

### 散列表算法
从字典中取值的算法流程图如下所示：

![](http://cdn.blog.yanzl.net/2017-07-30-hash_search.png)

+ 首先，python会调用`hash(search_key)`来计算search_key的散列值，然后把这个值最低的几位数字当做偏移量。
+ 根据计算出来的偏移量查找对应的表元
+ 如果表元不存在则抛出KeyError异常
+ 如果表元存在，则表元中会存在found_key:found_value,python会验证表元中的found_key是否和search_key相等，如果想等则返回found_value。
+ 如果`found_kay != search_key`，则发生了散列冲突，利用解决冲突的方法计算出下一个表元的位置，再次判断表元首否为空，直到抛出KeyError异常或者找到这个元素所在的表元为止。

#### 关于散列冲突
散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引依赖于这个数字的一部分，为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字在当做索引来寻找表元。
### dict的实现及其导致的结果
#### 键必须是可散列的
一个可散列的对象必须满足以下要求：

+ 支持`hash()`函数，并且通过`__hash__()`所得到的散列值是不变的
+ 支持通过`__eq__()`方法来检测性等性
+ 若`a == b`为真，则`hash(a) == hash(b)`也为真

#### 字典在内存上的开销巨大
具体原因上面已经提到过，散列表是稀疏数组，空间的利用率比较低。因此，如果要存放数量巨大的对象，使用元组或者命名元组是比较好的选择，这样做一方面能够避免散列表所消耗的空间，另一方面也无需记录中字段的名字在每个元素里都存一遍。
#### 键查询很快
字典的实现就是用空间换时间，虽然字典在内存上的开销很大，但查询速度也是非常快的。
#### 键的次序取决于添加顺序
当往字典中添加新建而又发生散列冲突的时候，新建可能会被安排到另一个新的位置，这会造成以不同元素顺序存入的两个字典，在存储过程中如果发生了散列冲突，则字典是相等的，但是键在字典中出现的顺序是不一样的。
#### 往字典中添加新键可能会改变已有键的顺序
在往字典中添加新的元素时，字典会启动是否需要扩容的判断，在扩容执行的时候，可能会发生新的散列冲突，导致原有的键的顺序发生了变化。

### set的实现及其导致的结果

set 和 frozenaet的实现也依赖于散列表，只是表元中存储的只有元素的引用，其特点和上面提到的字典的特点是一样的，总结如下：

+ 集合中的元素必须是可散列的
+ 集合很消耗内存
+ 集合可以很高效地判断元素是否存在于某个集合中
+ 元素的次序取决于被添加到集合中的次序
+ 忘记何种添加元素，可能会改变集合中已有的元素的次序

